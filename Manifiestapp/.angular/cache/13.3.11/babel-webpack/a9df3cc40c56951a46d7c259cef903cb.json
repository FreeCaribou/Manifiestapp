{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Main\\\\Document\\\\Code\\\\Manifiestapp\\\\Manifiestapp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { WebPlugin } from '@capacitor/core';\nexport class LocalNotificationsWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.pending = [];\n    this.hasNotificationSupport = () => {\n      if (!('Notification' in window) || !Notification.requestPermission) {\n        return false;\n      }\n      if (Notification.permission !== 'granted') {\n        // don't test for `new Notification` if permission has already been granted\n        // otherwise this sends a real notification on supported browsers\n        try {\n          new Notification('');\n        } catch (e) {\n          if (e.name == 'TypeError') {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n  }\n  createChannel() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      throw _this.unimplemented('Not implemented on web.');\n    })();\n  }\n  deleteChannel() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      throw _this2.unimplemented('Not implemented on web.');\n    })();\n  }\n  listChannels() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      throw _this3.unimplemented('Not implemented on web.');\n    })();\n  }\n  schedule(options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.hasNotificationSupport()) {\n        throw _this4.unavailable('Notifications not supported in this browser.');\n      }\n      for (const notification of options.notifications) {\n        _this4.sendNotification(notification);\n      }\n      return {\n        notifications: options.notifications.map(notification => ({\n          id: notification.id\n        }))\n      };\n    })();\n  }\n  getPending() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return {\n        notifications: _this5.pending\n      };\n    })();\n  }\n  registerActionTypes() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      throw _this6.unimplemented('Not implemented on web.');\n    })();\n  }\n  cancel(pending) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      _this7.pending = _this7.pending.filter(notification => !pending.notifications.find(n => n.id === notification.id));\n    })();\n  }\n  areEnabled() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        display\n      } = yield _this8.checkPermissions();\n      return {\n        value: display === 'granted'\n      };\n    })();\n  }\n  requestPermissions() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this9.hasNotificationSupport()) {\n        throw _this9.unavailable('Notifications not supported in this browser.');\n      }\n      const display = _this9.transformNotificationPermission(yield Notification.requestPermission());\n      return {\n        display\n      };\n    })();\n  }\n  checkPermissions() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this10.hasNotificationSupport()) {\n        throw _this10.unavailable('Notifications not supported in this browser.');\n      }\n      const display = _this10.transformNotificationPermission(Notification.permission);\n      return {\n        display\n      };\n    })();\n  }\n  transformNotificationPermission(permission) {\n    switch (permission) {\n      case 'granted':\n        return 'granted';\n      case 'denied':\n        return 'denied';\n      default:\n        return 'prompt';\n    }\n  }\n  sendPending() {\n    var _a;\n    const toRemove = [];\n    const now = new Date().getTime();\n    for (const notification of this.pending) {\n      if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) && notification.schedule.at.getTime() <= now) {\n        this.buildNotification(notification);\n        toRemove.push(notification);\n      }\n    }\n    this.pending = this.pending.filter(notification => !toRemove.find(n => n === notification));\n  }\n  sendNotification(notification) {\n    var _a;\n    if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n      const diff = notification.schedule.at.getTime() - new Date().getTime();\n      this.pending.push(notification);\n      setTimeout(() => {\n        this.sendPending();\n      }, diff);\n      return;\n    }\n    this.buildNotification(notification);\n  }\n  buildNotification(notification) {\n    const localNotification = new Notification(notification.title, {\n      body: notification.body\n    });\n    localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n    localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n    return localNotification;\n  }\n  onClick(notification) {\n    const data = {\n      actionId: 'tap',\n      notification\n    };\n    this.notifyListeners('localNotificationActionPerformed', data);\n  }\n  onShow(notification) {\n    this.notifyListeners('localNotificationReceived', notification);\n  }\n}\n//# sourceMappingURL=web.js.map","map":null,"metadata":{},"sourceType":"module"}
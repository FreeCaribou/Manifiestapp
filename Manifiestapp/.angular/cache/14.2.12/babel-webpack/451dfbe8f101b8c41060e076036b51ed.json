{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { EventEmitter } from '@angular/core';\nimport { of } from 'rxjs';\nimport { map, switchMap, tap } from 'rxjs/operators';\nimport { LocalStorageEnum } from 'src/app/shared/models/LocalStorage.enum';\nimport { LocalNotifications } from '@capacitor/local-notifications';\nimport { NotificationEventEnum } from 'src/app/shared/models/NotificationEvent.enum';\nimport { wpDateToRealDate } from 'src/app/shared/utils/wp-date-to-real-date';\nimport * as moment from 'moment';\nimport { formatDate } from '@angular/common';\nimport { environment } from '../../../../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./programme.data.service\";\nimport * as i2 from \"../volunteer-shift/volunteer-shift.service\";\nimport * as i3 from \"@ionic/angular\";\nimport * as i4 from \"@ngx-translate/core\";\nimport * as i5 from \"../../communication/language.communication.service\";\nimport * as i6 from \"../base.service\";\n// TODO clean old code from wordpress\nexport let ProgrammeService = /*#__PURE__*/(() => {\n  class ProgrammeService {\n    constructor(service, volunteerShiftService, toastController, translate, languageService, baseService) {\n      this.service = service;\n      this.volunteerShiftService = volunteerShiftService;\n      this.toastController = toastController;\n      this.translate = translate;\n      this.languageService = languageService;\n      this.baseService = baseService;\n      this.favoriteChangeEmit = new EventEmitter();\n      this.verificationFavoriteLoadEmit = new EventEmitter();\n      this.cacheBigBlobProgramme = [];\n      this.cacheBigBlobProgrammeChangeEmit$ = new EventEmitter();\n      this.languageService.langHasChangeEvent.subscribe(e => {\n        this.resetListCache();\n      });\n      localStorage.removeItem(LocalStorageEnum.FavoriteId);\n    }\n    retrieveProgrammeInLoop(url, count = 0, lastArray = [], maxPerPage = 50) {\n      let arrayToReturn = lastArray;\n      return this.baseService.getCall(`${url}&offset=${maxPerPage * count}&limit=${maxPerPage}`).pipe(switchMap(e => {\n        if (!Array.isArray(e.items)) {\n          return of(lastArray);\n        }\n        arrayToReturn = arrayToReturn.concat(e.items);\n        if (e.items.length === maxPerPage) {\n          return this.retrieveProgrammeInLoop(url, count + 1, arrayToReturn);\n        } else {\n          return of(arrayToReturn);\n        }\n      }));\n    }\n    getBigBlobAllProgramme() {\n      if (this.cacheBigBlobProgramme.length > 0) {\n        return of(this.cacheBigBlobProgrammeBrut);\n      }\n      let url = 'https://manifiesta.be/api/v2/pages/?type=event.EventPage';\n      url += '&fields=description,api_event_dates,api_location,image,api_categories,thumbnail';\n      url += '&locale=' + this.languageService.selectedLanguage;\n      url += '&format=json';\n      return this.retrieveProgrammeInLoop(url).pipe(\n      // Map and sort the date and hours\n      map(datas => {\n        try {\n          datas = datas.map(i => {\n            let dayInString = '';\n            switch (i.api_event_dates[0].day) {\n              case 'SAT':\n                dayInString = '2023-09-09T';\n                break;\n              case 'SUN':\n                dayInString = '2023-09-10T';\n                break;\n            }\n            return Object.assign(Object.assign({}, i), {\n              api_event_dates: [{\n                day: i.api_event_dates[0].day,\n                start: dayInString + i.api_event_dates[0].start,\n                end: dayInString + i.api_event_dates[0].end\n              }]\n            });\n          });\n        } catch (e) {\n          console.warn('error in mapping date and hour of event', e);\n        }\n        return datas;\n      }), map(datas => datas.sort((a, b) => {\n        return new Date(a.api_event_dates[0].start) > new Date(b.api_event_dates[0].start) ? 1 : -1;\n      })), map(e => {\n        return Object.assign(Object.assign({}, e), {\n          items: this.mapToFavorite(e)\n        });\n      }), tap(d => this.cacheBigBlobProgramme = d.items), tap(d => this.cacheBigBlobProgrammeBrut = d), tap(() => this.cacheBigBlobProgrammeChangeEmit$.emit()));\n    }\n    onlyGetFavoriteProgramme() {\n      const ids = this.getFavoriteId();\n      if (ids.length > 0) {\n        return this.getBigBlobAllProgramme().pipe(map(d => {\n          return d.items.filter(i => ids.includes(i.id.toString()));\n        }));\n      } else {\n        return of([]);\n      }\n    }\n    getFavoriteProgramme(ids) {\n      let shiftsList = [];\n      return this.getFavoriteId().length > 0 ? this.volunteerShiftService.getShifts().pipe(tap(data => {\n        shiftsList = data;\n      }), switchMap(e => {\n        return this.onlyGetFavoriteProgramme().pipe(map(e => this.mapToFavorite(e)), map(e => this.mapVerifyFavoriteConflict(e, shiftsList)));\n      })) : of([]);\n    }\n    getEvent(id) {\n      return this.service.getEvent(id).pipe(map(e => this.mapRawWpDataToClearData(e)), map(x => {\n        x.favorite = this.isFavorite(id);\n        return x;\n      }));\n    }\n    // no data call method\n    resetListCache() {\n      this.cacheBigBlobProgramme = [];\n      this.cacheBigBlobProgrammeBrut = null;\n    }\n    getFavoriteId() {\n      var _a;\n      return ((_a = localStorage.getItem(LocalStorageEnum.FavoriteId2023)) === null || _a === void 0 ? void 0 : _a.split(',')) || [];\n    }\n    changeFavorite(event) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const isChangedToFavorite = event.favorite = !event.favorite;\n        const favoriteId = this.getFavoriteId();\n        if (isChangedToFavorite && !favoriteId) {\n          localStorage.setItem(LocalStorageEnum.FavoriteId2023, [event.id.toString()].toString());\n        } else if (isChangedToFavorite && favoriteId) {\n          localStorage.setItem(LocalStorageEnum.FavoriteId2023, [...favoriteId, event.id.toString()].toString());\n        } else if (!isChangedToFavorite && favoriteId) {\n          const favoriteIdFiltered = favoriteId.filter(x => x !== event.id.toString());\n          if (favoriteIdFiltered.length > 0) {\n            localStorage.setItem(LocalStorageEnum.FavoriteId2023, favoriteId.filter(x => x !== event.id.toString()).toString());\n          } else {\n            localStorage.removeItem(LocalStorageEnum.FavoriteId2023);\n          }\n        }\n        // TODO adapt the notif\n        // const allNotif = await (await LocalNotifications.getPending()).notifications;\n        // if (event.favorite) {\n        //   await this.verifyEventHourConflictForNewFav(event);\n        //   if (!allNotif.find(x => x.id == event.id)) {\n        //     await this.addOneEventNotif(event);\n        //   }\n        // } else {\n        //   await this.cancelOneEventNotif(event, allNotif);\n        // }\n        this.favoriteChangeEmit.emit(event);\n      });\n    }\n    showOkNewFavoriteToast() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const toast = yield this.toastController.create({\n          message: yield this.translate.get('Programme.FavAdded').toPromise(),\n          icon: 'checkmark-circle-outline',\n          color: 'success',\n          duration: 1500,\n          position: 'top'\n        });\n        toast.present();\n      });\n    }\n    // TODO-refactor divide the code please ...\n    verifyEventHourConflictForNewFav(event) {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.verificationFavoriteLoadEmit.emit(true);\n        const favs = yield this.getFavoriteProgramme().toPromise();\n        if (favs.length > 1) {\n          const conflicts = favs.filter(e => {\n            return e.id !== event.id && this.verifyConflictBetweenToRangeOfDate(e, event);\n          });\n          if (conflicts.length > 0) {\n            let message = '';\n            conflicts.forEach((x, k) => {\n              message += `\"${x.title}\"${k + 1 === conflicts.length ? '' : ' and '}`;\n            });\n            const toast = yield this.toastController.create({\n              header: yield this.translate.get('Programme.HaveConflict').toPromise(),\n              message,\n              icon: 'alert-circle-outline',\n              color: 'warning',\n              duration: 5000\n            });\n            toast.present();\n          }\n          if (this.volunteerShiftService.getBeepleVolunteerId()) {\n            const shifts = yield this.volunteerShiftService.getShifts().toPromise();\n            const shiftConflict = shifts.filter(s => {\n              return this.verifyConflictBetweenToRangeOfDate(this.convertShiftTime(s), event);\n            });\n            if (shiftConflict.length > 0) {\n              let message = '';\n              shiftConflict.forEach((x, k) => {\n                var _a;\n                message += `\"${(_a = x.team) === null || _a === void 0 ? void 0 : _a.full_name}\"${k + 1 === shiftConflict.length ? '' : ' and '}`;\n              });\n              const toast = yield this.toastController.create({\n                header: yield this.translate.get('Programme.ConflictShifts').toPromise(),\n                message,\n                icon: 'alert-circle-outline',\n                color: 'warning',\n                duration: 5000\n              });\n              toast.present();\n            }\n          }\n        }\n        this.verificationFavoriteLoadEmit.emit(false);\n      });\n    }\n    // TODO beware in production with the date from wp ...\n    addOneEventNotif(event) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!localStorage.getItem(LocalStorageEnum.AvoidNotification) && event.api_event_dates[0].start) {\n          const startDateFormated = formatDate(event.api_event_dates[0].start, 'HH:mm', 'fr');\n          const body = yield this.translate.get('Programme.NotificationBody', {\n            event: event === null || event === void 0 ? void 0 : event.title,\n            startDate: startDateFormated,\n            location: event === null || event === void 0 ? void 0 : event.api_location.name\n          }).toPromise();\n          let scheduleDate;\n          if (environment.production) {\n            // For production, an half hour before the event\n            scheduleDate = new Date(new Date(event.api_event_dates[0].start).getTime() - 1000 * 60 * 30);\n          } else {\n            // For test, show notification 5 seconds after the click on fav\n            scheduleDate = new Date(Date.now() + 1000 * 15);\n          }\n          // We don't need to prepar a notification if the date is in the past !\n          if (scheduleDate > new Date()) {\n            yield LocalNotifications.schedule({\n              notifications: [{\n                title: `${event === null || event === void 0 ? void 0 : event.title} - ${startDateFormated}` || 'Check it',\n                id: event.id || 1,\n                body: body,\n                largeBody: body,\n                schedule: {\n                  at: scheduleDate,\n                  allowWhileIdle: true\n                },\n                autoCancel: true,\n                summaryText: yield this.translate.get('Programme.NotificationSummary').toPromise(),\n                actionTypeId: NotificationEventEnum.EventFav,\n                largeIcon: 'large_icon'\n              }]\n            });\n          }\n        }\n      });\n    }\n    cancelAllEventNotif() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const allNotif = yield (yield LocalNotifications.getPending()).notifications;\n        yield allNotif.forEach(n => __awaiter(this, void 0, void 0, function* () {\n          yield LocalNotifications.cancel({\n            notifications: [n]\n          });\n        }));\n      });\n    }\n    addAllNotification() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // to be sur to avoid doublon\n        yield this.cancelAllEventNotif();\n        const favorites = yield this.getFavoriteProgramme().toPromise();\n        yield favorites.forEach(e => __awaiter(this, void 0, void 0, function* () {\n          yield this.addOneEventNotif(e);\n        }));\n      });\n    }\n    cancelOneEventNotif(event, notifs) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield notifs.forEach(n => __awaiter(this, void 0, void 0, function* () {\n          if (n.id == parseInt(event.id)) {\n            yield LocalNotifications.cancel({\n              notifications: [n]\n            });\n          }\n        }));\n      });\n    }\n    isFavorite(id) {\n      var _a;\n      return (_a = this.getFavoriteId()) === null || _a === void 0 ? void 0 : _a.includes(id.toString());\n    }\n    mapToFavorite(events) {\n      events = events.map(x => {\n        x.favorite = this.isFavorite(x.id.toString());\n        return x;\n      });\n      return events;\n    }\n    filterFavorite(events) {\n      return events.filter(x => this.isFavorite(x.id));\n    }\n    // TODO-refactor seriously, better code is needed here ...\n    mapVerifyFavoriteConflict(events, shifts = []) {\n      return events.map(e => {\n        e.inFavoriteConflict = events.findIndex(i => {\n          return i.id !== e.id && this.verifyConflictBetweenToRangeOfDate(e, i);\n        }) > -1 || shifts.findIndex(s => {\n          return this.verifyConflictBetweenToRangeOfDate(e, this.convertShiftTime(s));\n        }) > -1;\n        return e;\n      });\n    }\n    // TODO-refactor type that\n    convertShiftTime(shift) {\n      var _a;\n      let shiftDate = (_a = shift.team) === null || _a === void 0 ? void 0 : _a.shifts[0];\n      shiftDate.startDate = shiftDate.start_datetime;\n      shiftDate.endDate = shiftDate.end_datetime;\n      return shiftDate;\n    }\n    verifyConflictBetweenToRangeOfDate(a, b) {\n      try {\n        const aStartDate = a.startDate || a.api_event_dates[0].start;\n        const aEndDate = a.endDate || a.api_event_dates[0].end;\n        const bStartDate = b.startDate || b.api_event_dates[0].start;\n        const bEndDate = b.endDate || b.api_event_dates[0].end;\n        return moment(aStartDate).isBetween(bStartDate, bEndDate, 'minutes', '()') || moment(aEndDate).isBetween(bStartDate, bEndDate, 'minutes', '()') || moment(aStartDate).isAfter(bStartDate) && moment(aEndDate).isBefore(bEndDate) || moment(aStartDate).isBefore(bStartDate) && moment(aEndDate).isAfter(bEndDate);\n      } catch (e) {\n        return false;\n      }\n    }\n    mapOrderByStartDate(events) {\n      return events.sort((a, b) => {\n        var _a, _b;\n        return ((_a = a.startDate) === null || _a === void 0 ? void 0 : _a.getTime()) - ((_b = b.startDate) === null || _b === void 0 ? void 0 : _b.getTime());\n      });\n    }\n    mapListEventToDayListEvent(events) {\n      const dayListEvent = [];\n      events.forEach(e => {\n        const index = dayListEvent.findIndex(x => e.api_event_dates[0].day === (x === null || x === void 0 ? void 0 : x.day));\n        if (index > -1) {\n          dayListEvent[index].events.push(e);\n        } else {\n          let dayDate;\n          switch (e.api_event_dates[0].day) {\n            case 'SAT':\n              dayDate = new Date('2023-09-09');\n              break;\n            case 'SUN':\n              dayDate = new Date('2023-09-10');\n              break;\n          }\n          dayListEvent.push({\n            day: e.api_event_dates[0].day,\n            dayDate,\n            events: [e]\n          });\n        }\n      });\n      return dayListEvent;\n    }\n    // Mapping the data from WordPress to cleaner data for the app\n    mapArrayRawWpDataToClearData(events) {\n      return events.map(e => {\n        return this.mapRawWpDataToClearData(e);\n      });\n    }\n    mapRawWpDataToClearData(event) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;\n      event.startDate = wpDateToRealDate((_c = (_b = (_a = event['toolset-meta']) === null || _a === void 0 ? void 0 : _a['info-evenement']) === null || _b === void 0 ? void 0 : _b['start-hour']) === null || _c === void 0 ? void 0 : _c.formatted, false);\n      event.endDate = wpDateToRealDate((_f = (_e = (_d = event['toolset-meta']) === null || _d === void 0 ? void 0 : _d['info-evenement']) === null || _e === void 0 ? void 0 : _e['end-hour']) === null || _f === void 0 ? void 0 : _f.formatted, false);\n      event.headline = (_g = event.title) === null || _g === void 0 ? void 0 : _g.rendered;\n      event.mainPictureUrl = ((_h = event._embedded) === null || _h === void 0 ? void 0 : _h['wp:featuredmedia']) && ((_k = (_j = event._embedded) === null || _j === void 0 ? void 0 : _j['wp:featuredmedia'][0]) === null || _k === void 0 ? void 0 : _k.source_url) ? (_m = (_l = event._embedded) === null || _l === void 0 ? void 0 : _l['wp:featuredmedia'][0]) === null || _m === void 0 ? void 0 : _m.source_url : 'assets/pictures/manifiesta-title-logo.jpg';\n      event.localisation = ((_o = event._embedded) === null || _o === void 0 ? void 0 : _o['wp:term']) ? (_q = (_p = event._embedded) === null || _p === void 0 ? void 0 : _p['wp:term'].find(x => x === null || x === void 0 ? void 0 : x.find(y => y.taxonomy === 'locatie'))) === null || _q === void 0 ? void 0 : _q[0] : null;\n      event.category = ((_r = event._embedded) === null || _r === void 0 ? void 0 : _r['wp:term']) ? (_t = (_s = event._embedded) === null || _s === void 0 ? void 0 : _s['wp:term'].find(x => x === null || x === void 0 ? void 0 : x.find(y => y.taxonomy === 'programmacategorie'))) === null || _t === void 0 ? void 0 : _t[0] : null;\n      event.day = ((_u = event._embedded) === null || _u === void 0 ? void 0 : _u['wp:term']) ? (_w = (_v = event._embedded) === null || _v === void 0 ? void 0 : _v['wp:term'].find(x => x === null || x === void 0 ? void 0 : x.find(y => (y === null || y === void 0 ? void 0 : y.taxonomy) === 'dag'))) === null || _w === void 0 ? void 0 : _w[0] : null;\n      return event;\n    }\n    // offline\n    setOfflineFavoritesList(events) {\n      localStorage.setItem(LocalStorageEnum.OfflineFavorites, JSON.stringify(events));\n    }\n    getOfflineFavoritesList() {\n      const tmp = localStorage.getItem(LocalStorageEnum.OfflineFavorites);\n      if (tmp) {\n        try {\n          return JSON.parse(localStorage.getItem(LocalStorageEnum.OfflineFavorites));\n        } catch (e) {\n          return [];\n        }\n      } else {\n        return [];\n      }\n    }\n    getOfflineProgrammesList(day) {\n      const tmp = localStorage.getItem(LocalStorageEnum.OfflineProgrammes);\n      if (tmp) {\n        try {\n          const programmesOffline = JSON.parse(localStorage.getItem(LocalStorageEnum.OfflineProgrammes));\n          const programmesCache = programmesOffline.find(x => x.days === day.toString());\n          return (programmesCache === null || programmesCache === void 0 ? void 0 : programmesCache.list) || [];\n        } catch (e) {\n          return [];\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n  ProgrammeService.ɵfac = function ProgrammeService_Factory(t) {\n    return new (t || ProgrammeService)(i0.ɵɵinject(i1.ProgrammeDataService), i0.ɵɵinject(i2.VolunteerShiftService), i0.ɵɵinject(i3.ToastController), i0.ɵɵinject(i4.TranslateService), i0.ɵɵinject(i5.LanguageCommunicationService), i0.ɵɵinject(i6.BaseService));\n  };\n  ProgrammeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProgrammeService,\n    factory: ProgrammeService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProgrammeService;\n})();","map":null,"metadata":{},"sourceType":"module"}
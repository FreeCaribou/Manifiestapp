{"ast":null,"code":"import _asyncToGenerator from \"C:/Main/Document/Code/Manifiestapp/Manifiestapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nconst NAMESPACE = 'ionicpwaelements';\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/snabbdom/snabbdom/blob/master/LICENSE\n *\n * Modified for Stencil's renderer and slot projection\n */\n\nlet scopeId;\nlet hostTagName;\nlet isSvgMode = false;\nlet queuePending = false;\n\nconst createTime = (fnName, tagName = '') => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\n\nconst uniqueTime = (key, measureText) => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\n\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\n/**\n * Default style mode id\n */\n\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\n\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\n\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\n\nconst isDef = v => v != null;\n/**\n * Check whether a value is a 'complex type', defined here as an object or a\n * function.\n *\n * @param o the value to check\n * @returns whether it's a complex type or not\n */\n\n\nconst isComplexType = o => {\n  // https://jsperf.com/typeof-fn-object/5\n  o = typeof o;\n  return o === 'object' || o === 'function';\n};\n/**\n * Helper method for querying a `meta` tag that contains a nonce value\n * out of a DOM's head.\n *\n * @param doc The DOM containing the `head` to query against\n * @returns The content of the meta tag representing the nonce value, or `undefined` if no tag\n * exists or the tag has no content.\n */\n\n\nfunction queryNonceMetaTagContent(doc) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = doc.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('content')) !== null && _c !== void 0 ? _c : undefined;\n}\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\n\n\nconst h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n\n  const walk = c => {\n    for (let i = 0; i < c.length; i++) {\n      child = c[i];\n\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== 'boolean') {\n        if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\n          child = String(child);\n        }\n\n        if (simple && lastSimple) {\n          // If the previous child was simple (string), we merge both\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          // Append a new vNode, if it's text, we create a text vNode\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n\n        lastSimple = simple;\n      }\n    }\n  };\n\n  walk(children);\n\n  if (vnodeData) {\n    {\n      const classData = vnodeData.className || vnodeData.class;\n\n      if (classData) {\n        vnodeData.class = typeof classData !== 'object' ? classData : Object.keys(classData).filter(k => classData[k]).join(' ');\n      }\n    }\n  }\n\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n\n  return vnode;\n};\n/**\n * A utility function for creating a virtual DOM node from a tag and some\n * possible text content.\n *\n * @param tag the tag for this element\n * @param text possible text content for the node\n * @returns a newly-minted virtual DOM node\n */\n\n\nconst newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  return vnode;\n};\n\nconst Host = {};\n/**\n * Check whether a given node is a Host node or not\n *\n * @param node the virtual DOM node to check\n * @returns whether it's a Host node or not\n */\n\nconst isHost = node => node && node.$tag$ === Host;\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\n\n\nconst parsePropertyValue = (propValue, propType) => {\n  // ensure this value is of the correct prop type\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4\n    /* MEMBER_FLAGS.Boolean */\n    ) {\n      // per the HTML spec, any string value means it is a boolean true value\n      // but we'll cheat here and say that the string \"false\" is the boolean false\n      return propValue === 'false' ? false : propValue === '' || !!propValue;\n    }\n\n    if (propType & 2\n    /* MEMBER_FLAGS.Number */\n    ) {\n      // force it to be a number\n      return parseFloat(propValue);\n    }\n\n    if (propType & 1\n    /* MEMBER_FLAGS.String */\n    ) {\n      // could have been passed as a number or boolean\n      // but we still want it as a string\n      return String(propValue);\n    } // redundant return here for better minification\n\n\n    return propValue;\n  } // not sure exactly what type we want\n  // so no need to change to a different type\n\n\n  return propValue;\n};\n\nconst getElement = ref => getHostRef(ref).$hostElement$;\n\nconst createEvent = (ref, name, flags) => {\n  const elm = getElement(ref);\n  return {\n    emit: detail => {\n      return emitEvent(elm, name, {\n        bubbles: !!(flags & 4\n        /* EVENT_FLAGS.Bubbles */\n        ),\n        composed: !!(flags & 2\n        /* EVENT_FLAGS.Composed */\n        ),\n        cancelable: !!(flags & 1\n        /* EVENT_FLAGS.Cancellable */\n        ),\n        detail\n      });\n    }\n  };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\n\n\nconst emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\n\nconst rootAppliedStyles = /*@__PURE__*/new WeakMap();\n\nconst registerStyle = (scopeId, cssText, allowCS) => {\n  let style = styles.get(scopeId);\n\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n\n    if (typeof style === 'string') {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n\n  styles.set(scopeId, style);\n};\n\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n  var _a;\n\n  let scopeId = getScopeId(cmpMeta);\n  const style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node\n  // so the fallback is to always use the document for the root node in those cases\n\n  styleContainerNode = styleContainerNode.nodeType === 11\n  /* NODE_TYPE.DocumentFragment */\n  ? styleContainerNode : doc;\n\n  if (style) {\n    if (typeof style === 'string') {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n      }\n\n      if (!appliedStyles.has(scopeId)) {\n        {\n          // TODO(STENCIL-659): Remove code implementing the CSS variable shim\n          {\n            styleElm = doc.createElement('style');\n            styleElm.innerHTML = style;\n          } // Apply CSP nonce to the style tag if it exists\n\n          const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);\n\n          if (nonce != null) {\n            styleElm.setAttribute('nonce', nonce);\n          }\n\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n        }\n\n        if (appliedStyles) {\n          appliedStyles.add(scopeId);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n    }\n  }\n\n  return scopeId;\n};\n\nconst attachStyles = hostRef => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n  const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta); // TODO(STENCIL-662): Remove code related to deprecated shadowDomShim field\n\n  if (flags & 10\n  /* CMP_FLAGS.needsScopedEncapsulation */\n  ) {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    // DOM WRITE!!\n    elm['s-sc'] = scopeId;\n    elm.classList.add(scopeId + '-h');\n  }\n\n  endAttachStyles();\n};\n\nconst getScopeId = (cmp, mode) => 'sc-' + cmp.$tagName$;\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n\n\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n  if (oldValue !== newValue) {\n    let isProp = isMemberInElement(elm, memberName);\n    let ln = memberName.toLowerCase();\n\n    if (memberName === 'class') {\n      const classList = elm.classList;\n      const oldClasses = parseClassList(oldValue);\n      const newClasses = parseClassList(newValue);\n      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n    } else if (memberName === 'style') {\n      // update style attribute, css properties and values\n      {\n        for (const prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (prop.includes('-')) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = '';\n            }\n          }\n        }\n      }\n\n      for (const prop in newValue) {\n        if (!oldValue || newValue[prop] !== oldValue[prop]) {\n          if (prop.includes('-')) {\n            elm.style.setProperty(prop, newValue[prop]);\n          } else {\n            elm.style[prop] = newValue[prop];\n          }\n        }\n      }\n    } else if (memberName === 'ref') {\n      // minifier will clean this up\n      if (newValue) {\n        newValue(elm);\n      }\n    } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {\n      // Event Handlers\n      // so if the member name starts with \"on\" and the 3rd characters is\n      // a capital letter, and it's not already a member on the element,\n      // then we're assuming it's an event listener\n      if (memberName[2] === '-') {\n        // on- prefixed events\n        // allows to be explicit about the dom event to listen without any magic\n        // under the hood:\n        // <my-cmp on-click> // listens for \"click\"\n        // <my-cmp on-Click> // listens for \"Click\"\n        // <my-cmp on-ionChange> // listens for \"ionChange\"\n        // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        // standard event\n        // the JSX attribute could have been \"onMouseOver\" and the\n        // member name \"onmouseover\" is on the window's prototype\n        // so let's add the listener \"mouseover\", which is all lowercased\n        memberName = ln.slice(2);\n      } else {\n        // custom event\n        // the JSX attribute could have been \"onMyCustomEvent\"\n        // so let's trim off the \"on\" prefix and lowercase the first character\n        // and add the listener \"myCustomEvent\"\n        // except for the first character, we keep the event name case\n        memberName = ln[2] + memberName.slice(3);\n      }\n\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, false);\n      }\n\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, false);\n      }\n    } else {\n      // Set property if it exists and it's not a SVG\n      const isComplex = isComplexType(newValue);\n\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes('-')) {\n            const n = newValue == null ? '' : newValue; // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n\n            if (memberName === 'list') {\n              isProp = false;\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {}\n      }\n\n      if (newValue == null || newValue === false) {\n        if (newValue !== false || elm.getAttribute(memberName) === '') {\n          {\n            elm.removeAttribute(memberName);\n          }\n        }\n      } else if ((!isProp || flags & 4\n      /* VNODE_FLAGS.isHost */\n      || isSvg) && !isComplex) {\n        newValue = newValue === true ? '' : newValue;\n        {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\n\nconst parseClassListRegex = /\\s/;\n\nconst parseClassList = value => !value ? [] : value.split(parseClassListRegex);\n\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n  // if the element passed in is a shadow root, which is a document fragment\n  // then we want to be adding attrs/props to the shadow root's \"host\" element\n  // if it's not a shadow root, then we add attrs/props to the same element\n  const elm = newVnode.$elm$.nodeType === 11\n  /* NODE_TYPE.DocumentFragment */\n  && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  {\n    // remove attributes no longer present on the vnode by setting them to undefined\n    for (memberName in oldVnodeAttrs) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n      }\n    }\n  } // add new & update changed attributes\n\n  for (memberName in newVnodeAttrs) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n  }\n};\n/**\n * Create a DOM Node corresponding to one of the children of a given VNode.\n *\n * @param oldParentVNode the parent VNode from the previous render\n * @param newParentVNode the parent VNode from the current render\n * @param childIndex the index of the VNode, in the _new_ parent node's\n * children, for which we will create a new DOM node\n * @param parentElm the parent DOM node which our new node will be a child of\n * @returns the newly created node\n */\n\n\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n  // tslint:disable-next-line: prefer-const\n  const newVNode = newParentVNode.$children$[childIndex];\n  let i = 0;\n  let elm;\n  let childNode;\n\n  if (newVNode.$text$ !== null) {\n    // create text node\n    elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n  } else {\n    if (!isSvgMode) {\n      isSvgMode = newVNode.$tag$ === 'svg';\n    } // create element\n\n\n    elm = newVNode.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$);\n\n    if (isSvgMode && newVNode.$tag$ === 'foreignObject') {\n      isSvgMode = false;\n    } // add css classes, attrs, props, listeners, etc.\n\n\n    {\n      updateElement(null, newVNode, isSvgMode);\n    }\n\n    if (isDef(scopeId) && elm['s-si'] !== scopeId) {\n      // if there is a scopeId and this is the initial render\n      // then let's add the scopeId as a css class\n      elm.classList.add(elm['s-si'] = scopeId);\n    }\n\n    if (newVNode.$children$) {\n      for (i = 0; i < newVNode.$children$.length; ++i) {\n        // create the node\n        childNode = createElm(oldParentVNode, newVNode, i); // return node could have been null\n\n        if (childNode) {\n          // append our new node\n          elm.appendChild(childNode);\n        }\n      }\n    }\n\n    {\n      if (newVNode.$tag$ === 'svg') {\n        // Only reset the SVG context when we're exiting <svg> element\n        isSvgMode = false;\n      } else if (elm.tagName === 'foreignObject') {\n        // Reenter SVG context when we're exiting <foreignObject> element\n        isSvgMode = true;\n      }\n    }\n  }\n\n  return elm;\n};\n/**\n * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and\n * add them to the DOM in the appropriate place.\n *\n * @param parentElm the DOM node which should be used as a parent for the new\n * DOM nodes\n * @param before a child of the `parentElm` which the new children should be\n * inserted before (optional)\n * @param parentVNode the parent virtual DOM node\n * @param vnodes the new child virtual DOM nodes to produce DOM nodes for\n * @param startIdx the index in the child virtual DOM nodes at which to start\n * creating DOM nodes (inclusive)\n * @param endIdx the index in the child virtual DOM nodes at which to stop\n * creating DOM nodes (inclusive)\n */\n\n\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        containerElm.insertBefore(childNode, before);\n      }\n    }\n  }\n};\n/**\n * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.\n * This can be used to, for instance, clean up after a list of children which\n * should no longer be shown.\n *\n * This function also handles some of Stencil's slot relocation logic.\n *\n * @param vnodes a list of virtual DOM nodes to remove\n * @param startIdx the index at which to start removing nodes (inclusive)\n * @param endIdx the index at which to stop removing nodes (inclusive)\n */\n\n\nconst removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n\n      if (elm) {\n        // remove the vnode's element from the dom\n        elm.remove();\n      }\n    }\n  }\n};\n/**\n * Reconcile the children of a new VNode with the children of an old VNode by\n * traversing the two collections of children, identifying nodes that are\n * conserved or changed, calling out to `patch` to make any necessary\n * updates to the DOM, and rearranging DOM nodes as needed.\n *\n * The algorithm for reconciling children works by analyzing two 'windows' onto\n * the two arrays of children (`oldCh` and `newCh`). We keep track of the\n * 'windows' by storing start and end indices and references to the\n * corresponding array entries. Initially the two 'windows' are basically equal\n * to the entire array, but we progressively narrow the windows until there are\n * no children left to update by doing the following:\n *\n * 1. Skip any `null` entries at the beginning or end of the two arrays, so\n *    that if we have an initial array like the following we'll end up dealing\n *    only with a window bounded by the highlighted elements:\n *\n *    [null, null, VNode1 , ... , VNode2, null, null]\n *                 ^^^^^^         ^^^^^^\n *\n * 2. Check to see if the elements at the head and tail positions are equal\n *    across the windows. This will basically detect elements which haven't\n *    been added, removed, or changed position, i.e. if you had the following\n *    VNode elements (represented as HTML):\n *\n *    oldVNode: `<div><p><span>HEY</span></p></div>`\n *    newVNode: `<div><p><span>THERE</span></p></div>`\n *\n *    Then when comparing the children of the `<div>` tag we check the equality\n *    of the VNodes corresponding to the `<p>` tags and, since they are the\n *    same tag in the same position, we'd be able to avoid completely\n *    re-rendering the subtree under them with a new DOM element and would just\n *    call out to `patch` to handle reconciling their children and so on.\n *\n * 3. Check, for both windows, to see if the element at the beginning of the\n *    window corresponds to the element at the end of the other window. This is\n *    a heuristic which will let us identify _some_ situations in which\n *    elements have changed position, for instance it _should_ detect that the\n *    children nodes themselves have not changed but merely moved in the\n *    following example:\n *\n *    oldVNode: `<div><element-one /><element-two /></div>`\n *    newVNode: `<div><element-two /><element-one /></div>`\n *\n *    If we find cases like this then we also need to move the concrete DOM\n *    elements corresponding to the moved children to write the re-order to the\n *    DOM.\n *\n * 4. Finally, if VNodes have the `key` attribute set on them we check for any\n *    nodes in the old children which have the same key as the first element in\n *    our window on the new children. If we find such a node we handle calling\n *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with\n *    what we find.\n *\n * Finally, once we've narrowed our 'windows' to the point that either of them\n * collapse (i.e. they have length 0) we then handle any remaining VNode\n * insertion or deletion that needs to happen to get a DOM state that correctly\n * reflects the new child VNodes. If, for instance, after our window on the old\n * children has collapsed we still have more nodes on the new children that\n * we haven't dealt with yet then we need to add them, or if the new children\n * collapse but we still have unhandled _old_ children then we need to make\n * sure the corresponding DOM nodes are removed.\n *\n * @param parentElm the node into which the parent VNode is rendered\n * @param oldCh the old children of the parent node\n * @param newVNode the new VNode which will replace the parent\n * @param newCh the new children of the parent node\n */\n\n\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      // VNode might have been moved left\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // if the start nodes are the same then we should patch the new VNode\n      // onto the old one, and increment our `newStartIdx` and `oldStartIdx`\n      // indices to reflect that. We don't need to move any DOM Nodes around\n      // since things are matched up in order.\n      patch(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // likewise, if the end nodes are the same we patch new onto old and\n      // decrement our end indices, and also likewise in this case we don't\n      // need to move any DOM Nodes.\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      patch(oldStartVnode, newEndVnode); // We need to move the element for `oldStartVnode` into a position which\n      // will be appropriate for `newEndVnode`. For this we can use\n      // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a\n      // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for\n      // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:\n      //\n      // <old-start-node />\n      // <some-intervening-node />\n      // <old-end-node />\n      // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here\n      // <next-sibling />\n      //\n      // If instead `oldEndVnode.$elm$` has no sibling then we just want to put\n      // the node for `oldStartVnode` at the end of the children of\n      // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there\n      // aren't any siblings, and passing `null` to `Node.insertBefore` will\n      // append it to the children of the parent element.\n\n      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      patch(oldEndVnode, newStartVnode); // We've already checked above if `oldStartVnode` and `newStartVnode` are\n      // the same node, so since we're here we know that they are not. Thus we\n      // can move the element for `oldEndVnode` _before_ the element for\n      // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the\n      // future.\n\n      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      {\n        // We either didn't find an element in the old children that matches\n        // the key of the first new child OR the build is not using `key`\n        // attributes at all. In either case we need to create a new element\n        // for the new node.\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n\n      if (node) {\n        // if we created a new node then handle inserting it to the DOM\n        {\n          oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    // we have some more new nodes to add which don't match up with old nodes\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    // there are nodes in the `oldCh` array which no longer correspond to nodes\n    // in the new array, so lets remove them (which entails cleaning up the\n    // relevant DOM nodes)\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\n/**\n * Compare two VNodes to determine if they are the same\n *\n * **NB**: This function is an equality _heuristic_ based on the available\n * information set on the two VNodes and can be misleading under certain\n * circumstances. In particular, if the two nodes do not have `key` attrs\n * (available under `$key$` on VNodes) then the function falls back on merely\n * checking that they have the same tag.\n *\n * So, in other words, if `key` attrs are not set on VNodes which may be\n * changing order within a `children` array or something along those lines then\n * we could obtain a false negative and then have to do needless re-rendering\n * (i.e. we'd say two VNodes aren't equal when in fact they should be).\n *\n * @param leftVNode the first VNode to check\n * @param rightVNode the second VNode to check\n * @returns whether they're equal or not\n */\n\n\nconst isSameVnode = (leftVNode, rightVNode) => {\n  // compare if two vnode to see if they're \"technically\" the same\n  // need to have the same element tag, and same key to be the same\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handle reconciling an outdated VNode with a new one which corresponds to\n * it. This function handles flushing updates to the DOM and reconciling the\n * children of the two nodes (if any).\n *\n * @param oldVNode an old VNode whose DOM element and children we want to update\n * @param newVNode a new VNode representing an updated version of the old one\n */\n\n\nconst patch = (oldVNode, newVNode) => {\n  const elm = newVNode.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode.$children$;\n  const tag = newVNode.$tag$;\n  const text = newVNode.$text$;\n\n  if (text === null) {\n    {\n      // test if we're rendering an svg element, or still rendering nodes inside of one\n      // only add this to the when the compiler sees we're using an svg somewhere\n      isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n    }\n    {\n      {\n        // either this is the first render of an element OR it's an update\n        // AND we already know it's possible it could have changed\n        // this updates the element's css classes, attrs, props, listeners, etc.\n        updateElement(oldVNode, newVNode, isSvgMode);\n      }\n    }\n\n    if (oldChildren !== null && newChildren !== null) {\n      // looks like there's child vnodes for both the old and new vnodes\n      // so we need to call `updateChildren` to reconcile them\n      updateChildren(elm, oldChildren, newVNode, newChildren);\n    } else if (newChildren !== null) {\n      // no old child vnodes, but there are new child vnodes to add\n      if (oldVNode.$text$ !== null) {\n        // the old vnode was text, so be sure to clear it out\n        elm.textContent = '';\n      } // add the new vnode children\n\n\n      addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n    } else if (oldChildren !== null) {\n      // no new child vnodes, but there are old child vnodes to remove\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n\n    if (isSvgMode && tag === 'svg') {\n      isSvgMode = false;\n    }\n  } else if (oldVNode.$text$ !== text) {\n    // update the text content for the text only vnode\n    // and also only if the text is different than before\n    elm.data = text;\n  }\n};\n/**\n * 'Nullify' any VDom `ref` callbacks on a VDom node or its children by\n * calling them with `null`. This signals that the DOM element corresponding to\n * the VDom node has been removed from the DOM.\n *\n * @param vNode a virtual DOM node\n */\n\n\nconst nullifyVNodeRefs = vNode => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\n/**\n * The main entry point for Stencil's virtual DOM-based rendering engine\n *\n * Given a {@link d.HostRef} container and some virtual DOM nodes, this\n * function will handle creating a virtual DOM tree with a single root, patching\n * the current virtual DOM tree onto an old one (if any), dealing with slot\n * relocation, and reflecting attributes.\n *\n * @param hostRef data needed to root and render the virtual DOM tree, such as\n * the DOM node into which it should be rendered.\n * @param renderFnResults the virtual DOM nodes to be rendered\n */\n\n\nconst renderVdom = (hostRef, renderFnResults) => {\n  const hostElm = hostRef.$hostElement$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4\n  /* VNODE_FLAGS.isHost */\n  ;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  {\n    scopeId = hostElm['s-sc'];\n  } // synchronous patch\n\n  patch(oldVNode, rootVnode);\n};\n\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n    ancestorComponent['s-p'].push(new Promise(r => hostRef.$onRenderResolve$ = r));\n  }\n};\n\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16\n    /* HOST_FLAGS.isQueuedForUpdate */\n    ;\n  }\n\n  if (hostRef.$flags$ & 4\n  /* HOST_FLAGS.isWaitingForChildren */\n  ) {\n    hostRef.$flags$ |= 512\n    /* HOST_FLAGS.needsRerender */\n    ;\n    return;\n  }\n\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$); // there is no ancestor component or the ancestor component\n  // has already fired off its lifecycle update then\n  // fire off the initial update\n\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n\n  return writeTask(dispatch);\n};\n/**\n * Dispatch initial-render and update lifecycle hooks, enqueuing calls to\n * component lifecycle methods like `componentWillLoad` as well as\n * {@link updateComponent}, which will kick off the virtual DOM re-render.\n *\n * @param hostRef a reference to a host DOM node\n * @param isInitialLoad whether we're on the initial load or not\n * @returns an empty Promise which is used to enqueue a series of operations for\n * the component\n */\n\n\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n  const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n  const instance = hostRef.$lazyInstance$; // We're going to use this variable together with `enqueue` to implement a\n  // little promise-based queue. We start out with it `undefined`. When we add\n  // the first function to the queue we'll set this variable to be that\n  // function's return value. When we attempt to add subsequent values to the\n  // queue we'll check that value and, if it was a `Promise`, we'll then chain\n  // the new function off of that `Promise` using `.then()`. This will give our\n  // queue two nice properties:\n  //\n  // 1. If all functions added to the queue are synchronous they'll be called\n  //    synchronously right away.\n  // 2. If all functions added to the queue are asynchronous they'll all be\n  //    called in order after `dispatchHooks` exits.\n\n  let maybePromise;\n\n  if (isInitialLoad) {\n    {\n      hostRef.$flags$ |= 256\n      /* HOST_FLAGS.isListenReady */\n      ;\n\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n        hostRef.$queuedListeners$ = undefined;\n      }\n    }\n  }\n\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\n/**\n * This function uses a Promise to implement a simple first-in, first-out queue\n * of functions to be called.\n *\n * The queue is ordered on the basis of the first argument. If it's\n * `undefined`, then nothing is on the queue yet, so the provided function can\n * be called synchronously (although note that this function may return a\n * `Promise`). The idea is that then the return value of that enqueueing\n * operation is kept around, so that if it was a `Promise` then subsequent\n * functions can be enqueued by calling this function again with that `Promise`\n * as the first argument.\n *\n * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel\n * @param fn a function to enqueue\n * @returns either a `Promise` or the return value of the provided function\n */\n\n\nconst enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();\n/**\n * Check that a value is a `Promise`. To check, we first see if the value is an\n * instance of the `Promise` global. In a few circumstances, in particular if\n * the global has been overwritten, this is could be misleading, so we also do\n * a little 'duck typing' check to see if the `.then` property of the value is\n * defined and a function.\n *\n * @param maybePromise it might be a promise!\n * @returns whether it is or not\n */\n\n\nconst isPromisey = maybePromise => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === 'function';\n\nconst updateComponent = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (hostRef, instance, isInitialLoad) {\n    var _a;\n\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n\n    if (isInitialLoad) {\n      // DOM WRITE!\n      attachStyles(hostRef);\n    }\n\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    {\n      callRender(hostRef, instance);\n    }\n\n    if (rc) {\n      // ok, so turns out there are some child host elements\n      // waiting on this parent element to load\n      // let's fire off all update callbacks waiting\n      rc.map(cb => cb());\n      elm['s-rc'] = undefined;\n    }\n\n    endRender();\n    endUpdate();\n    {\n      const childrenPromises = (_a = elm['s-p']) !== null && _a !== void 0 ? _a : [];\n\n      const postUpdate = () => postUpdateComponent(hostRef);\n\n      if (childrenPromises.length === 0) {\n        postUpdate();\n      } else {\n        Promise.all(childrenPromises).then(postUpdate);\n        hostRef.$flags$ |= 4\n        /* HOST_FLAGS.isWaitingForChildren */\n        ;\n        childrenPromises.length = 0;\n      }\n    }\n  });\n\n  return function updateComponent(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst callRender = (hostRef, instance, elm) => {\n  try {\n    instance = instance.render();\n    {\n      hostRef.$flags$ &= ~16\n      /* HOST_FLAGS.isQueuedForUpdate */\n      ;\n    }\n    {\n      hostRef.$flags$ |= 2\n      /* HOST_FLAGS.hasRendered */\n      ;\n    }\n    {\n      {\n        // looks like we've got child nodes to render into this host element\n        // or we need to update the css class/attrs on the host element\n        // DOM WRITE!\n        {\n          renderVdom(hostRef, instance);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n\n  return null;\n};\n\nconst postUpdateComponent = hostRef => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime('postUpdate', tagName);\n  const instance = hostRef.$lazyInstance$;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n\n  if (!(hostRef.$flags$ & 64\n  /* HOST_FLAGS.hasLoadedComponent */\n  )) {\n    hostRef.$flags$ |= 64\n    /* HOST_FLAGS.hasLoadedComponent */\n    ;\n    {\n      // DOM WRITE!\n      addHydratedFlag(elm);\n    }\n    {\n      safeCall(instance, 'componentDidLoad');\n    }\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    endPostUpdate();\n  }\n\n  {\n    hostRef.$onInstanceResolve$(elm);\n  } // load events fire from bottom to top\n  // the deepest elements load first then bubbles up\n\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = undefined;\n    }\n\n    if (hostRef.$flags$ & 512\n    /* HOST_FLAGS.needsRerender */\n    ) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n\n    hostRef.$flags$ &= ~(4\n    /* HOST_FLAGS.isWaitingForChildren */\n    | 512\n    /* HOST_FLAGS.needsRerender */\n    );\n  } // ( •_•)\n  // ( •_•)>⌐■-■\n  // (⌐■_■)\n};\n\nconst forceUpdate = ref => {\n  {\n    const hostRef = getHostRef(ref);\n    const isConnected = hostRef.$hostElement$.isConnected;\n\n    if (isConnected && (hostRef.$flags$ & (2\n    /* HOST_FLAGS.hasRendered */\n    | 16\n    /* HOST_FLAGS.isQueuedForUpdate */\n    )) === 2\n    /* HOST_FLAGS.hasRendered */\n    ) {\n      scheduleUpdate(hostRef, false);\n    } // Returns \"true\" when the forced update was successfully scheduled\n\n\n    return isConnected;\n  }\n};\n\nconst appDidLoad = who => {\n  // on appload\n  // we have finish the first big initial render\n  {\n    addHydratedFlag(doc.documentElement);\n  }\n  nextTick(() => emitEvent(win, 'appload', {\n    detail: {\n      namespace: NAMESPACE\n    }\n  }));\n};\n\nconst safeCall = (instance, method, arg) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  return undefined;\n};\n\nconst addHydratedFlag = elm => elm.classList.add('hydrated');\n\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\n\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n  // check our new property value against our internal value\n  const hostRef = getHostRef(ref);\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = hostRef.$lazyInstance$;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]); // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n\n  if ((!(flags & 8\n  /* HOST_FLAGS.isConstructingInstance */\n  ) || oldVal === undefined) && didValueChange) {\n    // gadzooks! the property's value has changed!!\n    // set our new value!\n    hostRef.$instanceValues$.set(propName, newVal);\n\n    if (instance) {\n      if ((flags & (2\n      /* HOST_FLAGS.hasRendered */\n      | 16\n      /* HOST_FLAGS.isQueuedForUpdate */\n      )) === 2\n      /* HOST_FLAGS.hasRendered */\n      ) {\n        // looks like this value actually changed, so we've got work to do!\n        // but only if we've already rendered, otherwise just chill out\n        // queue that we need to do an update, but don't worry about queuing\n        // up millions cuz this function ensures it only runs once\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n/**\n * Attach a series of runtime constructs to a compiled Stencil component\n * constructor, including getters and setters for the `@Prop` and `@State`\n * decorators, callbacks for when attributes change, and so on.\n *\n * @param Cstr the constructor for a component that we need to process\n * @param cmpMeta metadata collected previously about the component\n * @param flags a number used to store a series of bit flags\n * @returns a reference to the same constructor passed in (but now mutated)\n */\n\n\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n  if (cmpMeta.$members$) {\n    // It's better to have a const than two Object.entries()\n    const members = Object.entries(cmpMeta.$members$);\n    const prototype = Cstr.prototype;\n    members.map(([memberName, [memberFlags]]) => {\n      if (memberFlags & 31\n      /* MEMBER_FLAGS.Prop */\n      || flags & 2\n      /* PROXY_FLAGS.proxyState */\n      && memberFlags & 32\n      /* MEMBER_FLAGS.State */\n      ) {\n        // proxyComponent - prop\n        Object.defineProperty(prototype, memberName, {\n          get() {\n            // proxyComponent, get value\n            return getValue(this, memberName);\n          },\n\n          set(newValue) {\n            // proxyComponent, set value\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n\n          configurable: true,\n          enumerable: true\n        });\n      } else if (flags & 1\n      /* PROXY_FLAGS.isElementConstructor */\n      && memberFlags & 64\n      /* MEMBER_FLAGS.Method */\n      ) {\n        // proxyComponent - method\n        Object.defineProperty(prototype, memberName, {\n          value(...args) {\n            const ref = getHostRef(this);\n            return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n          }\n\n        });\n      }\n    });\n\n    if (flags & 1\n    /* PROXY_FLAGS.isElementConstructor */\n    ) {\n      const attrNameToPropName = new Map();\n\n      prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n        plt.jmp(() => {\n          const propName = attrNameToPropName.get(attrName); //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n          //  in the case where an attribute was set inline.\n          //  ```html\n          //    <my-component some-attribute=\"some-value\"></my-component>\n          //  ```\n          //\n          //  There is an edge case where a developer sets the attribute inline on a custom element and then\n          //  programmatically changes it before it has been upgraded as shown below:\n          //\n          //  ```html\n          //    <!-- this component has _not_ been upgraded yet -->\n          //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n          //    <script>\n          //      // grab non-upgraded component\n          //      el = document.querySelector(\"#test\");\n          //      el.someAttribute = \"another-value\";\n          //      // upgrade component\n          //      customElements.define('my-component', MyComponent);\n          //    </script>\n          //  ```\n          //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n          //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n          //  to the value that was set inline i.e. \"some-value\" from above example. When\n          //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n          //\n          //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n          //  by connectedCallback as this attributeChangedCallback will not fire.\n          //\n          //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n          //\n          //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n          //  properties here given that this goes against best practices outlined here\n          //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n\n          if (this.hasOwnProperty(propName)) {\n            newValue = this[propName];\n            delete this[propName];\n          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === 'number' && this[propName] == newValue) {\n            // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n            // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n            // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n            return;\n          }\n\n          this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n        });\n      }; // create an array of attributes to observe\n      // and also create a map of html attribute name to js property name\n\n\n      Cstr.observedAttributes = members.filter(([_, m]) => m[0] & 15\n      /* MEMBER_FLAGS.HasAttribute */\n      ) // filter to only keep props that should match attributes\n      .map(([propName, m]) => {\n        const attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n        return attrName;\n      });\n    }\n  }\n\n  return Cstr;\n};\n\nconst initializeComponent = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (elm, hostRef, cmpMeta, hmrVersionId, Cstr) {\n    // initializeComponent\n    if ((hostRef.$flags$ & 32\n    /* HOST_FLAGS.hasInitializedComponent */\n    ) === 0) {\n      // Let the runtime know that the component has been initialized\n      hostRef.$flags$ |= 32\n      /* HOST_FLAGS.hasInitializedComponent */\n      ;\n      {\n        // lazy loaded components\n        // request the component's implementation to be\n        // wired up with the host element\n        Cstr = loadModule(cmpMeta);\n\n        if (Cstr.then) {\n          // Await creates a micro-task avoid if possible\n          const endLoad = uniqueTime();\n          Cstr = yield Cstr;\n          endLoad();\n        }\n\n        if (!Cstr.isProxied) {\n          proxyComponent(Cstr, cmpMeta, 2\n          /* PROXY_FLAGS.proxyState */\n          );\n          Cstr.isProxied = true;\n        }\n\n        const endNewInstance = createTime('createInstance', cmpMeta.$tagName$); // ok, time to construct the instance\n        // but let's keep track of when we start and stop\n        // so that the getters/setters don't incorrectly step on data\n\n        {\n          hostRef.$flags$ |= 8\n          /* HOST_FLAGS.isConstructingInstance */\n          ;\n        } // construct the lazy-loaded component implementation\n        // passing the hostRef is very important during\n        // construction in order to directly wire together the\n        // host element and the lazy-loaded instance\n\n        try {\n          new Cstr(hostRef);\n        } catch (e) {\n          consoleError(e);\n        }\n\n        {\n          hostRef.$flags$ &= ~8\n          /* HOST_FLAGS.isConstructingInstance */\n          ;\n        }\n        endNewInstance();\n      }\n\n      if (Cstr.style) {\n        // this component has styles but we haven't registered them yet\n        let style = Cstr.style;\n        const scopeId = getScopeId(cmpMeta);\n\n        if (!styles.has(scopeId)) {\n          const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n          registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1\n          /* CMP_FLAGS.shadowDomEncapsulation */\n          ));\n          endRegisterStyles();\n        }\n      }\n    } // we've successfully created a lazy instance\n\n\n    const ancestorComponent = hostRef.$ancestorComponent$;\n\n    const schedule = () => scheduleUpdate(hostRef, true);\n\n    if (ancestorComponent && ancestorComponent['s-rc']) {\n      // this is the initial load and this component it has an ancestor component\n      // but the ancestor component has NOT fired its will update lifecycle yet\n      // so let's just cool our jets and wait for the ancestor to continue first\n      // this will get fired off when the ancestor component\n      // finally gets around to rendering its lazy self\n      // fire off the initial update\n      ancestorComponent['s-rc'].push(schedule);\n    } else {\n      schedule();\n    }\n  });\n\n  return function initializeComponent(_x4, _x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst connectedCallback = elm => {\n  if ((plt.$flags$ & 1\n  /* PLATFORM_FLAGS.isTmpDisconnected */\n  ) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n\n    if (!(hostRef.$flags$ & 1\n    /* HOST_FLAGS.hasConnected */\n    )) {\n      // first time this component has connected\n      hostRef.$flags$ |= 1\n      /* HOST_FLAGS.hasConnected */\n      ;\n      {\n        // find the first ancestor component (if there is one) and register\n        // this component as one of the actively loading child components for its ancestor\n        let ancestorComponent = elm;\n\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          // climb up the ancestors looking for the first\n          // component that hasn't finished its lifecycle update yet\n          if (ancestorComponent['s-p']) {\n            // we found this components first ancestor component\n            // keep a reference to this component's ancestor component\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      } // Lazy properties\n      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31\n          /* MEMBER_FLAGS.Prop */\n          && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n\n      {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      // not the first time this has connected\n      // reattach any event listeners to the host\n      // since they would have been removed when disconnected\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n    }\n\n    endConnected();\n  }\n};\n\nconst disconnectedCallback = elm => {\n  if ((plt.$flags$ & 1\n  /* PLATFORM_FLAGS.isTmpDisconnected */\n  ) === 0) {\n    const hostRef = getHostRef(elm);\n    const instance = hostRef.$lazyInstance$;\n    {\n      if (hostRef.$rmListeners$) {\n        hostRef.$rmListeners$.map(rmListener => rmListener());\n        hostRef.$rmListeners$ = undefined;\n      }\n    }\n    {\n      safeCall(instance, 'disconnectedCallback');\n    }\n  }\n};\n\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n  var _a;\n\n  const endBootstrap = createTime();\n  const cmpTags = [];\n  const exclude = options.exclude || [];\n  const customElements = win.customElements;\n  const head = doc.head;\n  const metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');\n  const visibilityStyle = /*@__PURE__*/doc.createElement('style');\n  const deferredConnectedCallbacks = [];\n  let appLoadFallback;\n  let isBootstrapping = true;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n  lazyBundles.map(lazyBundle => {\n    lazyBundle[1].map(compactMeta => {\n      const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n      {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n      {\n        cmpMeta.$listeners$ = compactMeta[3];\n      }\n      const tagName = cmpMeta.$tagName$;\n      const HostElement = class extends HTMLElement {\n        // StencilLazyHost\n        constructor(self) {\n          // @ts-ignore\n          super(self);\n          self = this;\n          registerHost(self, cmpMeta);\n\n          if (cmpMeta.$flags$ & 1\n          /* CMP_FLAGS.shadowDomEncapsulation */\n          ) {\n            // this component is using shadow dom\n            // and this browser supports shadow dom\n            // add the read-only property \"shadowRoot\" to the host element\n            // adding the shadow root build conditionals to minimize runtime\n            {\n              {\n                self.attachShadow({\n                  mode: 'open'\n                });\n              }\n            }\n          }\n        }\n\n        connectedCallback() {\n          if (appLoadFallback) {\n            clearTimeout(appLoadFallback);\n            appLoadFallback = null;\n          }\n\n          if (isBootstrapping) {\n            // connectedCallback will be processed once all components have been registered\n            deferredConnectedCallbacks.push(this);\n          } else {\n            plt.jmp(() => connectedCallback(this));\n          }\n        }\n\n        disconnectedCallback() {\n          plt.jmp(() => disconnectedCallback(this));\n        }\n\n        componentOnReady() {\n          return getHostRef(this).$onReadyPromise$;\n        }\n\n      };\n      cmpMeta.$lazyBundleId$ = lazyBundle[0];\n\n      if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1\n        /* PROXY_FLAGS.isElementConstructor */\n        ));\n      }\n    });\n  });\n  {\n    visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n    visibilityStyle.setAttribute('data-styles', ''); // Apply CSP nonce to the style tag if it exists\n\n    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);\n\n    if (nonce != null) {\n      visibilityStyle.setAttribute('nonce', nonce);\n    }\n\n    head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n  } // Process deferred connectedCallbacks now all components have been registered\n\n  isBootstrapping = false;\n\n  if (deferredConnectedCallbacks.length) {\n    deferredConnectedCallbacks.map(host => host.connectedCallback());\n  } else {\n    {\n      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));\n    }\n  } // Fallback appLoad event\n\n\n  endBootstrap();\n};\n\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n  if (listeners) {\n    listeners.map(([flags, name, method]) => {\n      const target = getHostListenerTarget(elm, flags);\n      const handler = hostListenerProxy(hostRef, method);\n      const opts = hostListenerOpts(flags);\n      plt.ael(target, name, handler, opts);\n      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n    });\n  }\n};\n\nconst hostListenerProxy = (hostRef, methodName) => ev => {\n  try {\n    {\n      if (hostRef.$flags$ & 256\n      /* HOST_FLAGS.isListenReady */\n      ) {\n        // instance is ready, let's call it's member method for this event\n        hostRef.$lazyInstance$[methodName](ev);\n      } else {\n        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n      }\n    }\n  } catch (e) {\n    consoleError(e);\n  }\n};\n\nconst getHostListenerTarget = (elm, flags) => {\n  if (flags & 16\n  /* LISTENER_FLAGS.TargetBody */\n  ) return doc.body;\n  return elm;\n}; // prettier-ignore\n\n\nconst hostListenerOpts = flags => (flags & 2\n/* LISTENER_FLAGS.Capture */\n) !== 0;\n/**\n * Assigns the given value to the nonce property on the runtime platform object.\n * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.\n * @param nonce The value to be assigned to the platform nonce property.\n * @returns void\n */\n\n\nconst setNonce = nonce => plt.$nonce$ = nonce;\n\nconst hostRefs = /*@__PURE__*/new WeakMap();\n\nconst getHostRef = ref => hostRefs.get(ref);\n\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\n\nconst registerHost = (elm, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: elm,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: new Map()\n  };\n  {\n    hostRef.$onInstancePromise$ = new Promise(r => hostRef.$onInstanceResolve$ = r);\n  }\n  {\n    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n    elm['s-p'] = [];\n    elm['s-rc'] = [];\n  }\n  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n  return hostRefs.set(elm, hostRef);\n};\n\nconst isMemberInElement = (elm, memberName) => memberName in elm;\n\nconst consoleError = (e, el) => (0, console.error)(e, el);\n\nconst cmpModules = /*@__PURE__*/new Map();\n\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n  // loadModuleImport\n  const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n  const bundleId = cmpMeta.$lazyBundleId$;\n  const module = cmpModules.get(bundleId);\n\n  if (module) {\n    return module[exportName];\n  }\n\n  if (!hmrVersionId || !BUILD.hotModuleReplacement) {\n    const processMod = importedModule => {\n      cmpModules.set(bundleId, importedModule);\n      return importedModule[exportName];\n    };\n\n    switch (bundleId) {\n      case 'pwa-action-sheet':\n        return import(\n        /* webpackMode: \"lazy\" */\n        './pwa-action-sheet.entry.js').then(processMod, consoleError);\n\n      case 'pwa-camera-modal':\n        return import(\n        /* webpackMode: \"lazy\" */\n        './pwa-camera-modal.entry.js').then(processMod, consoleError);\n\n      case 'pwa-toast':\n        return import(\n        /* webpackMode: \"lazy\" */\n        './pwa-toast.entry.js').then(processMod, consoleError);\n\n      case 'pwa-camera-modal-instance':\n        return import(\n        /* webpackMode: \"lazy\" */\n        './pwa-camera-modal-instance.entry.js').then(processMod, consoleError);\n\n      case 'pwa-camera':\n        return import(\n        /* webpackMode: \"lazy\" */\n        './pwa-camera.entry.js').then(processMod, consoleError);\n    }\n  }\n\n  return import(\n  /* @vite-ignore */\n\n  /* webpackInclude: /\\.entry\\.js$/ */\n\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n\n  /* webpackMode: \"lazy\" */\n  `./${bundleId}.entry.js${''}`).then(importedModule => {\n    {\n      cmpModules.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n};\n\nconst styles = /*@__PURE__*/new Map();\nconst win = typeof window !== 'undefined' ? window : {};\nconst doc = win.document || {\n  head: {}\n};\nconst plt = {\n  $flags$: 0,\n  $resourcesUrl$: '',\n  jmp: h => h(),\n  raf: h => requestAnimationFrame(h),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\n\nconst promiseResolve = v => Promise.resolve(v);\n\nconst supportsConstructableStylesheets = /*@__PURE__*/(() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === 'function';\n  } catch (e) {}\n\n  return false;\n})();\n\nconst queueDomReads = [];\nconst queueDomWrites = [];\n\nconst queueTask = (queue, write) => cb => {\n  queue.push(cb);\n\n  if (!queuePending) {\n    queuePending = true;\n\n    if (write && plt.$flags$ & 4\n    /* PLATFORM_FLAGS.queueSync */\n    ) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\n\nconst consume = queue => {\n  for (let i = 0; i < queue.length; i++) {\n    try {\n      queue[i](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n\n  queue.length = 0;\n};\n\nconst flush = () => {\n  // always force a bunch of medium callbacks to run, but still have\n  // a throttle on how many can run in a certain time\n  // DOM READS!!!\n  consume(queueDomReads); // DOM WRITES!!!\n\n  {\n    consume(queueDomWrites);\n\n    if (queuePending = queueDomReads.length > 0) {\n      // still more to do yet, but we've run out of time\n      // let's let this thing cool off and try again in the next tick\n      plt.raf(flush);\n    }\n  }\n};\n\nconst nextTick = /*@__PURE__*/cb => promiseResolve().then(cb);\n\nconst writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);\nexport { Host as H, bootstrapLazy as b, createEvent as c, forceUpdate as f, getElement as g, h, promiseResolve as p, registerInstance as r, setNonce as s };","map":null,"metadata":{},"sourceType":"module"}